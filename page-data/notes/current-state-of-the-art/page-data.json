{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notes/current-state-of-the-art","result":{"data":{"brainNote":{"slug":"current-state-of-the-art","title":"current-state-of-the-art","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"GPGPU Tools on the Market\"), mdx(\"h3\", null, \"OpenACC\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.openacc.org/\"\n  }), \"OpenACC\"), \" is a mature set of extensions to native C compilers that allow the programmer to decorate portions of code with preprocessor pragmas. These tell the compiler to 'accelerate' certain parts of the code, and OpenACC takes care of the rest. \"), mdx(\"h3\", null, \"Altihmesh Hybridizer\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.altimesh.com/get-started/\"\n  }), \"Hybridizer\"), \" is a compiler for C# and/or Java that allows you to target any sort of hardware. It only supports a subset of C#, and appears to only work with CUDA. Once again, decorators are used to outline which pieces of the code should execute on the device, and which should stay on the host. Not available without paying for a license, which is $250/yr per seat. \"), mdx(\"h3\", null, \"Xcelerit-SDK\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.xcelerit.com/products/xcelerit-sdk/\"\n  }), \"Xcelerit\"), \" has some nice marketing on the website. True to typical software marketing, however, it fails to tell you in any detail what the product \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actually does\"), \". It supposedly automagically accelerates your code and can target GPUs, many-cored CPUs or multiple CPUs, etc. Even has MATLAB extensions. Found a form on their website to 'request source code', although I'm not sure what for. \"), mdx(\"h3\", null, \"SYCL\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/SYCL\"\n  }), \"SYCL\"), \" is a C++11 DSL for working with OpenCL. This, to me, seems to be the closest thing to what I've been envisioning, especially since OpenCL already has the concept of 'runtimes' for devices. That said, it is still C++. Also, it's just a standard, and the implementations for it aren't exactly numerous or well known. I did find \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.codeplay.com/solutions/ecosystem/\"\n  }), \"ComputeCPP\"), \", which claims full compliance to SYCL 1.2.1. Looks somewhat interesting. \"), mdx(\"h3\", null, \"DirectCompute\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://en.wikipedia.org/wiki/DirectCompute\"\n  }), \"DirectCompute\"), \" is Microsoft's entry into this part of the world. It more or less tries to get normal programs to fit into shader processors on GPUs. \"), mdx(\"h2\", null, \"Perhaps I Overestimated\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notes/maybe-not\"\n  }), \"Maybe Not\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"gpgpu-productivity","slug":"gpgpu-productivity","childMdx":{"excerpt":"Improving GPGPU This project is aimed at finding out about the latest and greatest in GPGPU technology, looking for tools, platforms, and…"}},{"title":"gpu-hll-vm","slug":"gpu-hll-vm","childMdx":{"excerpt":"Towards a better GPU programming experience GPGPU computation dominates the field of computing today, because it's just so damn useful. The…"}},{"title":"looking-into-java-based-technologies","slug":"looking-into-java-based-technologies","childMdx":{"excerpt":"A Ton of Java GPGPU Resources This morning (20201019), I shifted my focus from GPU centric technologies like CUDA/OpenCL and the others…"}},{"title":"maybe-not","slug":"maybe-not","childMdx":{"excerpt":"There May Be Room! So, after a more thorough review of what's on the market in  Current state of the art , I'm less convinced tonight than I…"}}],"outboundReferenceNotes":[{"title":"maybe-not","slug":"maybe-not","childMdx":{"excerpt":"There May Be Room! So, after a more thorough review of what's on the market in  Current state of the art , I'm less convinced tonight than I…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"current-state-of-the-art"}},"staticQueryHashes":[]}