{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notes/20200620184557-a-new-method-for-structural-properties-esimation","result":{"data":{"brainNote":{"slug":"20200620184557-a-new-method-for-structural-properties-esimation","title":"20200620184557-a-new-method-for-structural-properties-esimation","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200620184557-a-new-method-for-structural-properties-esimation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A new method for mass and structural properties estimation Thursday, December 12, 2019 5:40 PM For an assembly of N parts:\"), mdx(\"p\", null, \"\\xA0 \\xA0 m = sum(i, m\", mdx(\"sub\", null, \"i\"), \") \\xA0 \\xA0 cg\", mdx(\"sub\", null, \"i\"), \" = sum(j, m\", mdx(\"sub\", null, \"j\"), \"*\", \"cg\", mdx(\"sub\", null, \"ji\"), \") \", \"[i = x, y, z]\", \" \\xA0 \\xA0 MOI(cg)\", mdx(\"sub\", null, \"i\"), \" = sum(I\", mdx(\"sub\", null, \"i\"), \" + m\", mdx(\"sub\", null, \"i\"), \"*\", \"r\", mdx(\"sup\", null, \"2\"), \") \", \"[i=x,y,z]\", \" \\xA0 \\xA0 What about I\", mdx(\"sub\", null, \"ij\"), \", i=/= j?\"), mdx(\"p\", null, \"For clarity, m\", mdx(\"sub\", null, \"i\"), \", cg\", mdx(\"sub\", null, \"i\"), \", and I\", mdx(\"sub\", null, \"ii\"), \" are stochastic variables.\"), mdx(\"p\", null, \"for simulation/analysis purposes, we'd like to find a good estimate of the distribution of these summary parameters. Ideally, it would be really nice to get an idea of the distributions of things like structural margins and vibrational characteristics (body-bending, etc). The first question (of m, cg, I\", mdx(\"sub\", null, \"ii\"), \") is easy enough to answer due to analytic relations for those existing.\"), mdx(\"p\", null, \"the second question seems to be nearly impossible in the general case, at least analytically. Sure, FEM works, but that's an entire job in and of itself. But it would be cool to build a suite which does this from the outset! Maybe a tool that meshes and analyzes ITP/STEP files would be a good start. What about Elmer or its alternatives?\"), mdx(\"p\", null, \"I kinda like where this is going. I think I'm going to have to spend some time on this. What about Salome Meca and/or Code Aster?\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200620184557-a-new-method-for-structural-properties-esimation"}},"staticQueryHashes":[]}