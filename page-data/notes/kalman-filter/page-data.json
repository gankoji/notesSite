{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notes/kalman-filter","result":{"data":{"brainNote":{"slug":"kalman-filter","title":"kalman-filter","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"kalman-filter\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A KF is a linear transformation process applied to a time varying signal to estimate some desired state. We call the input signal z, or the measurement, and the output estimate x, or state. The process goes roughly like this:\"), mdx(\"p\", null, \"Get new measurement, z\", mdx(\"sub\", null, \"o\"), \". Predict what the next state should be, based on our model of the dynamics. Predict what the measurement should be, based on current state prediction. Compute the covariance of the measurement signal. Compute the Kalman Gain, which is the ratio of the two covariances.\"), mdx(\"p\", null, \"Finally, compute the state estimate as the blended combination of the prediction and the measurement, where the blending factor is the Kalman Gain. Also compute the covariance of the estimate signal, again using the Kalman Gain.\"), mdx(\"p\", null, \"Lather, rinse, repeat. This is a recursive process, so we need a seed value (an initial state distribution guess, i.e. a point estimate and a covariance).\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"kalman-filter"}},"staticQueryHashes":[]}