{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/brain/20200621100020-silence","result":{"data":{"brainNote":{"slug":"20200621100020-silence","title":"20200621100020-silence","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200621100020-silence\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Reading a paper simply titled \\\"Silence\\\", on communication in distributed systems. Since sending messages between agents in a distributed system incurs a cost in storage, bandwidth, energy and CPU time, it is desirable to minimize the system's need for them. This work introduces a framework in which decisions are made via \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"not\"), \" transmitting messages, where n rounds of complete silence indicate all voting members are in agreement. They then demonstrate the technique for the case of distributed transaction processing in large, online databases.\"), mdx(\"p\", null, \"@article{goren\", mdx(\"sub\", null, \"silence\"), mdx(\"sub\", null, \"2020\"), \", title = {Silence}, volume = {67}, issn = {0004-5411}, url = {\", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://doi.org/10.1145/3377883\"\n  }), \"https://doi.org/10.1145/3377883\"), \"}, doi = {10.1145/3377883}, abstract = {The cost of communication is a substantial factor affecting the scalability of many distributed applications. Every message sent can incur a cost in storage, computation, energy, and bandwidth. Consequently, reducing the communication costs of distributed applications is highly desirable. The best way to reduce message costs is by communicating without sending any messages whatsoever. This article initiates a rigorous investigation into the use of silence in synchronous settings, in which processes can fail. We formalize sufficient conditions for information transfer using silence, as well as necessary conditions for particular cases of interest. This allows us to identify message patterns that enable communication through silence. In particular, a pattern called a silent choir is identified, and shown to be central to information transfer via silence in failure-prone systems. The power of the new framework is demonstrated on the atomic commitment problem (AC). A complete characterization of the tradeoff between message complexity and round complexity in the synchronous model with crash failures is provided, in terms of lower bounds and matching protocols. In particular, a new message-optimal AC protocol is designed using silence, in which processes decide in three rounds in the common case. This significantly improves on the best previously known message-optimal AC protocol, in which decisions were performed in \\u0398(n) rounds. And in the naked light I saw Ten thousand people, maybe more People talking without speaking \\u2026 People writing songs that voices never share And no one dared Disturb the sound of silence Paul Simon, 1964}, number = {1}, urldate = {2020-05-25}, journal = {Journal of the ACM}, author = {Goren, Guy and Moses, Yoram}, month = jan, year = {2020}, keywords = {atomic commitment, consensus, fault-tolerance, knowledge, null messages, optimality, silent choir, Silent information exchange}, pages = {3:1\", \"\\u2013\", \"3:26}, file = {Goren\", mdx(\"sub\", null, \"Moses\"), mdx(\"sub\", null, \"2020\"), mdx(\"sub\", null, \"Silence.pdf\"), \":C\", \"\\\\\", \":\", \"\\\\\", \"\\\\Users\", \"\\\\\", \"\\\\asaxp\", \"\\\\\", \"\\\\Google Drive\", \"\\\\\", \"\\\\Zotero\", \"\\\\\", \"\\\\Goren\", mdx(\"sub\", null, \"Moses\"), mdx(\"sub\", null, \"2020\"), mdx(\"sub\", null, \"Silence.pdf\"), \":application/pdf} }\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200621100020-silence"}},"staticQueryHashes":[]}