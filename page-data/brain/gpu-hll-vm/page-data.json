{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/brain/gpu-hll-vm","result":{"data":{"brainNote":{"slug":"gpu-hll-vm","title":"gpu-hll-vm","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Towards a better GPU programming experience\"), mdx(\"p\", null, \"GPGPU computation dominates the field of computing today, because it's just so damn useful. The main trouble is, that it's a giant PITA to write any sort of software that can really leverage the GPU. One of my research goals is to rectify this situation. \"), mdx(\"h3\", null, \"Lessons learned from Java and Javascript\"), mdx(\"p\", null, \"The two most dominant languages in the world, the ones with which the lion's share of the software used globally is written, are both 'hosted' environments. Java has the JVM, and javascript the web browser. These are effective abstractions of underlying machine hardware, and they enable developers to focus more thoroughly on their intended applications, rather than the limitations of particular machines. They're not without drawbacks, particularly in the performance category, but those problems continue to be whittled away by the massive communities that support these technologies. \"), mdx(\"p\", null, \"What's most important about the rise of these languages/environments is that it shows us, empirically, the most important aspect of language design: developer velocity trumps nearly \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"everything else\"), \". We have the machine horsepower these days to be more cavalier in our treatment of resource constraints, especially when you consider the ability of applications to scale horizontally in the cloud. \"), mdx(\"h3\", null, \"How does this apply to GPUs?\"), mdx(\"p\", null, \"It doesn't, just yet. The truth is, that in 2020 GPU programming is still incredibly difficult. It takes a serious mountain of domain expert knowledge, and relies on technologies like Vulkan, DirectX, Metal, OpenGL, or the compute technologies CUDA and OpenCL. Frankly, each one of these technologies has a major drawback in that \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"developer velocity asymptotically approaches zero as project size and/or number of devices supported increases\"), \". These platforms simply aren't conducive to large scale, broad coverage development. I personally find this to be the primary reason why GPU acceleration is still in such a fledgling state. \"), mdx(\"h3\", null, \"What's the solution?\"), mdx(\"p\", null, \"I think the answer is quite obvious, and it's clear that at least some other folks are thinking about (though, not very many). OpenCL is probably the most forward looking of the bunch mentioned above, as they've at least recognized the need for (and built some lower level systems to provide) a runtime environment for accelerators. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This is the path we need to take\"), \". I'm cooking up the idea of basically 'JVM for GPUs'. We need some sort of virtual machine/runtime/interpreter/emulator to abstract away the type of details that make GPGPU so difficult: memory access/pipelining, device thread/block/stream configuration, etc. Additionally, we need to make the programmer environment much more friendly. C is straight up not a high velocity language anymore. Something more along the lines of Java, Python, or even Scheme/CL/Clojure would be more appropriate for today. Bonus points if we can get this to work with one of these existing languages. POCL-R seems pretty interesting, and even moderately applicable to this goal. \"), mdx(\"h3\", null, \"What I'm researching now\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The Garbage Collection Handbook: I think this is important to get a good understanding of automating resource management on the accelerators themselves. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtual Machines (Cain): He actually has good coverage of the JVM, which is the main inspiration here. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Virtual Machines (Smith): Not that great of a reference, but it does have a couple sections on HLL VMs (JVM, etc) that could be useful. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Advanced Design and Implementation of VMs: I'm hopeful \")), mdx(\"h3\", null, \"This may already be done...\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/brain/current-state-of-the-art\"\n  }), \"Current state of the art\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"gpgpu-productivity","slug":"gpgpu-productivity","childMdx":{"excerpt":"Improving GPGPU This project is aimed at finding out about the latest and greatest in GPGPU technology, looking for tools, platforms, and…"}}],"outboundReferenceNotes":[{"title":"current-state-of-the-art","slug":"current-state-of-the-art","childMdx":{"excerpt":"GPGPU Tools on the Market OpenACC OpenACC  is a mature set of extensions to native C compilers that allow the programmer to decorate…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"gpu-hll-vm"}},"staticQueryHashes":[]}