{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/brain/20200620210305-heaps-data-structure","result":{"data":{"brainNote":{"slug":"20200620210305-heaps-data-structure","title":"20200620210305-heaps-data-structure","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200620210305-heaps-data-structure\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Heaps Saturday, April 4, 2020 4:14 PM\"), mdx(\"p\", null, \"Heaps are a slick way to implement a binary tree without wasting space on pointers. However, their structure prevents implementing a binary search tree without requiring the use of 2\", mdx(\"sup\", null, \"n\"), \" spaces of contiguous memory for storage.\"), mdx(\"p\", null, \"The basic property, called the \\\"heap property\\\", is that each node dominates its children, in either a min or max sense. The maintenance of a heap involves bubbling up or down an element recursively. A node at location k has children at location 2\", \"*\", \"k and 2\", \"*\", \"k+1. Heaps are useful as priority queues, and enable heapsort, which runs in n\", \"*\", \"log n time, just like the other sorting options.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200620210305-heaps-data-structure"}},"staticQueryHashes":[]}