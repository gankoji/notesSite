{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/20200706141054-sortbenchmark-rules","result":{"data":{"brainNote":{"slug":"20200706141054-sortbenchmark-rules","title":"20200706141054-sortbenchmark-rules","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200706141054-sortbenchmark-rules\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The basic rules are pretty simple: there's a program that the contest distibutes called 'gensort' which must be used to generate the records to be sorted. The records themselves are 100 bytes of randomly generated data, with the first 10 bytes to be considered a random key. I'm a bit unclear as to how those bytes should be treated (big endian? unsigned?) when comparing them for sorting, so I'll have to figure that out. Maybe it's up to the programmer?\"), mdx(\"p\", null, \"There are two overarching 'type categories': Daytona and Indy. Daytona programs must be general purpose, i.e. capable of sorting generic records. Indy programs only need to be capable of sorting the exact format of records mentioned above.\"), mdx(\"p\", null, \"A few other small details: the sorted file must be an operating system file, so no direct IO tricks are allowed. The file must be checked for sorted order as part of the routine, and checksums must be calcualted and verified against the original data. Finally, program startup time is included in the time score of the entry, which obviously has a big impact on multi-machine solutions, like the cloud competitors.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200706141054-sortbenchmark-rules"}},"staticQueryHashes":[]}