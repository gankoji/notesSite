{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/20200619121746-fp-kalman-filter","result":{"data":{"brainNote":{"slug":"20200619121746-fp-kalman-filter","title":"20200619121746-fp-kalman-filter","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200619121746-fp-kalman-filter\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Just to cement my understanding of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"20200619114230-functional_programming.md\"\n  }), \"Functional Programming\"), \" a little bit further, I thought I'd compare and contrast OOP/FP with a concrete example from my field: the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"Kalman%20Filter\"\n  }), \"Kalman Filter\"), \".\"), mdx(\"p\", null, \"So, in the OOP world, a Kalman Filter is most often given it's own class. Measurement signals are fed in, and the state estimate is output at each time instance. The rest of the data just mentioned above is held internal to the class. This is seen as nice and tidy, but the potential for side effects is massive. There is a possiblity for reuse, but more often than not, these classes are bespoke, not resuing prevvious solutions because the class often ends up internalizing the dynamics and measurement models, linearization methods, etc. Algorithm designers are often poor software engineers.\"), mdx(\"p\", null, \"In a functional paradigm, we might implement this much differently: We'd extract methods from this pipeline as first class citizens: a general method for matrix multiplication (which usually exists in a library), a general method for computing arbitrarily sized covariance matrices, a method for blending estimates, a method for prediction, measurement conversion, etc. Then, the KF process would simply be a pipeline of these methods, almost exactly as we have it written above. If we want to change the performance of the filter by modifying tuning matrices, or changing the dynamic model, we simply feed in slightly different data to the pipeline, instead of creating a new child class so we don't mess up the old filter, etc. Clearly, a superior way to organize code in this particular case.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200619121746-fp-kalman-filter"}},"staticQueryHashes":[]}