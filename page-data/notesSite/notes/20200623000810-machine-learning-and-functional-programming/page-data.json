{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/20200623000810-machine-learning-and-functional-programming","result":{"data":{"brainNote":{"slug":"20200623000810-machine-learning-and-functional-programming","title":"20200623000810-machine-learning-and-functional-programming","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200623000810-machine-learning-and-functional-programming\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"One of the key insights I had last night while I was stewing on the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"Reinforcement%20Learning%20for%20Design\"\n  }), \"Reinforcement Learning for Design\"), \" topic was that of the difficulty inherent in such a massive reinforcement learning project, and how you'd need serious software tools in order to be able to tackle a project of that complexity effectively. This brought up the ideas of distributed systems, parallelizability, and functional programming.\"), mdx(\"p\", null, \"Distributed systems and parallelization of the problem are necessary here for obvious reasons: any serious attempt at optimization which incorporates finite element simulations for things like structural, thermal, or fluid dynamics is going to need a lot of horsepower just for those simulations, so doing them many times over in an optimization search is going to need exponentially more. Effectively, being able to distribute these problems trivially is necessary to scale the resource utilization to the time and space complexity of the problem being solved.\"), mdx(\"p\", null, \"Functional programming, on the other hand, came up as the solution to the complexity of design problem. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"20200623001541-the_curse_of_dimensionality.md\"\n  }), \"The Curse of Dimensionality\"), \" explains pretty succinctly the hopelessness of manually managing relationships between that many variables. Thus, we need a way to abstract these relationships as much as possible, and have them applied automatically in a sensible way. The way to do so in my mind is to apply the concept of composability: if we have 1e9 objects/points/dimensions in a problem, but they all fit uniquely into a handful of types, and the rules of interaction are clearly defined within or between those types, then we can consistently, systematically, and most importantly automatically apply those constraint rules even across such a massive set. The key way in my mind to do so is to start from the bottom up, defining a sufficiently granular atom of the system under consideration, and work your way up through rulesets and types of atoms, then to molecules and their rules for interaction (and how these interactions impact at the atom level), etc until we reach the whole system. Obviously, I'm being liberal with the words 'atom' and 'molecule' here, and don't necessarily mean atoms of the atomic scale (unless the problem itself calls for such a scale).\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200623000810-machine-learning-and-functional-programming"}},"staticQueryHashes":[]}