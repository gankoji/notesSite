{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/lru-cache-problem","result":{"data":{"brainNote":{"slug":"lru-cache-problem","title":"lru-cache-problem","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"lru-cache-problem\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"An LRU (Least Recently Used) cache does just that: it caches N values of a datastore, and these N are necessarily the N values that have most recently been accessed. The name comes from the fact that at each cache miss (i.e. a get from the datastore, followed by an insert \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"into\"), \" the cache), the least recently used element is discarded/overwritten. \"), mdx(\"p\", null, \"We have two main operations in an LRU cache: cache hit, and cache miss. If we access the cache, and the item we've requested is in the cache, it returns the item and we update the cache to note that this item was just accessed. If we miss, we get the item from the datastore (a long running operation, which we ignore for this analysis) and place it into the cache, overwriting the LRU element. Both of these operations should run in amortized O(log n) time. \"), mdx(\"p\", null, \"Getting a hit to return in O(log n) or better time is trivial: we implement the underlying cache-store as a hash table. On a request, we hash the request, index the table, and check for existence. If the item is there, return it. \"), mdx(\"p\", null, \"Getting a miss to return in O(log n) time is much more difficult: we realize now that we need extra information about the contents of the cache in order to make a determination as to which of them was least recently used. The ideal choice for this extra structure is a doubly linked list. \"), mdx(\"p\", null, \"On miss, we get the object from the store (again, ignored here). We then also add a the item's identifier (most likely its hash) to the front of the doubly linked list (O(1)). We keep two pointers to the LRU list: front and back. After the id is added to the LRU list, we insert it into the hash table (O(m), where m is the depth of our collision space). \"), mdx(\"p\", null, \"On hit, we have more work to do now. We get the item from the table (O(m)), we search for the item in the LRU list, remove it from it's current spot (O(n)), and add it to the front of the LRU list (O(1)). Oops, looks like this violates the O(log n) we needed earlier! The trick here is to expand our memory usage, and keep a reference in each hash element to it's spot in the queue. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"data-structures-for-running-minmax","slug":"data-structures-for-running-minmax","childMdx":{"excerpt":"Here, we consider the implementation of a queue like structure for maintaining the minimum of a set of values. This topic is also applicableâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"lru-cache-problem"}},"staticQueryHashes":[]}