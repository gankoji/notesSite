{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/sorting-large-files-with-memory-mapping","result":{"data":{"brainNote":{"slug":"sorting-large-files-with-memory-mapping","title":"sorting-large-files-with-memory-mapping","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notesSite/notes/memory-mapping-in-c\"\n  }), \"Memory Mapping in C\"), \" got this topic started, now it's time to get down to brass tax and sort out the details related to the PiSort program. We're up against a bit of a barrier here, because not only is the system memory much smaller than the files we're up against, but the disk isn't infinite (in fact it's just slightly less than 2x the input file size). So, no matter what, we cannot do a sort that leaves the input file as is (we would need at least 2x space to do so). \"), mdx(\"p\", null, \"So how do we go about efficiently cannibalizing the space? We can memory map it, read in a memory load, work with it, and rewrite it back exactly where it was. That's super space efficient, but does it work once we start merging runs? I guess it does if we're only merging adjacent runs. But why is adjacency required there, is that just sloppy thinking on my part?\"), mdx(\"p\", null, \"The greedsort algorithm is designed to have a separate output file. Can we re-use the input file as the output? I think that's possible, but we'll need a temp file that's big enough to hold the first L runs from the input file, so that we have L x M bytes of space available at the beginning of the input file to place our output. Then, provided we get the speed of ingest and output right, this should leave us enough cushion to successfully do the whole merge. Might have to rework that temp storage at every new merge level.  \"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notesSite/notes/greedsort\"\n  }), \"GreedSort\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notesSite/notes/greedsort-metadata\"\n  }), \"GreedSort Metadata\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notesSite/notes/coming-back-to-memory-mapping\"\n  }), \"Coming back to memory mapping\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[{"title":"memory-mapping-in-c","slug":"memory-mapping-in-c","childMdx":{"excerpt":"This is a continuation of sorts of  File Data Structures . An idea that came up is to memory map the three files we're using (input, temp…"}},{"title":"greedsort","slug":"greedsort","childMdx":{"excerpt":"The Actual Algorithm behind the PiSort project See  202008181021 Breaking Down GreedSort  for more details. Here, I want to give a very high…"}},{"title":"greedsort-metadata","slug":"greedsort-metadata","childMdx":{"excerpt":"What about all that auxiliary data? GreedSort focuses its memory requirements mostly on the M records worth of memory we'll need for each…"}},{"title":"coming-back-to-memory-mapping","slug":"coming-back-to-memory-mapping","childMdx":{"excerpt":"So, I've strayed from this topic for a few weeks, but I think it's time I picked it back up! We only have 9 days until the submission…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"sorting-large-files-with-memory-mapping"}},"staticQueryHashes":[]}