{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/20200706142338-solution-ideas","result":{"data":{"brainNote":{"slug":"20200706142338-solution-ideas","title":"20200706142338-solution-ideas","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200706142338-solution-ideas\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"I thought it would be really interesting to see if a solution involving one or more embedded SBCs might do the trick for the Joule sort competition. The full load consumption of the RPi4 is about 6.1W, so provided one of those could finish the 1 TB sort task in less than 7.5ish hours, it would win against the current Daytona champion. It would have to go down to about 4 hours for the Indy sort version. One thing to note is that both current champions used multiple NVMe drives for throughput, so an RPi4 might be at a significant disadvantage, since it lacks the capability for NVMe throughput.\"), mdx(\"p\", null, \"Looking through all the past submissions, it doesn't look like anyone's run an RPi4 ever in this contest, or at least won with one. Still, it could be an interesting excercise. One thing I don't like is that most everyone is using the Nsort program, which is commericially licensed by Ordinal Technologies. Their website doesn't mention a price for the license, but it looks like a one man company with one commerical product, so I can't imagine that it's going to be cheap. I think I'll at least try to write my own. Ideas for that can be found in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"20200706150158-sorting_algorithms_for_external_storage\"\n  }), \"Sorting Algorithms for External Storage\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200706142338-solution-ideas"}},"staticQueryHashes":[]}