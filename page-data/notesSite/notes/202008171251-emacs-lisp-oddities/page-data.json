{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/202008171251-emacs-lisp-oddities","result":{"data":{"brainNote":{"slug":"202008171251-emacs-lisp-oddities","title":"202008171251-emacs-lisp-oddities","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"202008171251-emacs-lisp-oddities\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"Emacs Lisp is Strange\"), mdx(\"p\", null, \"Not that strange, but it does have some crufty bits that make it harder to use (in my opinion anyway) than say Racket or Clojure. However, when we're dealing with text files specifically, there's such a rich library of functions already out there to handle opening them, moving through them, adding and removing text, etc, that it just makes sense to use elisp instead of one of the others and starting from scratch-ish. It \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"is\"), \" relatively slow, as it took roughly 2 minutes to iterate through a list of 140 small text files, add a line to the top, adjust the paragraph spacing, and run org export to markdown. I imagine that most of that time was spent in org-export, but I didn't profile it so I don't know for sure. \"), mdx(\"p\", null, \"One thing is for sure though, and that is that using a functional programming style in a lisp language made this task \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"signficantly\"), \" easier than it would have been in, say, python. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"202008171251-emacs-lisp-oddities"}},"staticQueryHashes":[]}