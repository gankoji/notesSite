{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/indexing-the-slipbox","result":{"data":{"brainNote":{"slug":"indexing-the-slipbox","title":"indexing-the-slipbox","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/notesSite/notes/nonconfusing-index-name\"\n  }), \"Nonconfusing Index Name\")), mdx(\"p\", null, \"As this slip box grows, the index will grow to match it. At some point, it will be far too large to bear manual searching, so I need to think through some strategies to handle that. At the moment, we know of a few options: there's spacemacs' default text search, which requires an exact match. There's helm's fuzzy completion engine, which is more along the lines of what I want, but only works for completing file/buffer names in its current state.\"), mdx(\"p\", null, \"Update: turns out I was wrong! There are two options for using helm for incremental search in a buffer: helm-occur, which comes with the basic helm distribution, and another package called helm-swoop. I'm going to give them both a shot and see how they work.\"), mdx(\"p\", null, \"Helm-swoop is much, much better and easier to use. SPC s s is the keybind, I may leave it like that because it's easy to remember and out of the way of everything else.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"about-these-notes","slug":"about-these-notes","childMdx":{"excerpt":"About These Notes Hi, and welcome to my slipbox! As you may have already guessed, this site is a style-clone of  Andy Matuschak's awesome…"}}],"outboundReferenceNotes":[{"title":"nonconfusing-index-name","slug":"nonconfusing-index-name","childMdx":{"excerpt":"This is the index card, the place where I can find jumping off points for all of my note trails. Noting Workflow Functional Programming…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"indexing-the-slipbox"}},"staticQueryHashes":[]}