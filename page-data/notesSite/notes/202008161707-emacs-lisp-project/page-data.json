{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/notesSite/notes/202008161707-emacs-lisp-project","result":{"data":{"brainNote":{"slug":"202008161707-emacs-lisp-project","title":"202008161707-emacs-lisp-project","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"202008161707-emacs-lisp-project\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Cool idea: Since I've now set myself the task of taking each one of the hundred or so files I have socked away in the slipbox and turning it into markdown (to be compatible with Obsidian), and there are a few annoying bits about the conversion process, why not just write a few functions in elisp and automate it? Lots of time saved (if I managed to write the functions in, oh, four hours or less) and a lot of learning in the process. Don't forget to use the REPL for testing!\"), mdx(\"p\", null, \"Primary conversion is handled by org-export. But, as of right now, org-export has TOC insertion on by default, and the only way I know to turn it off is to add a macro to the top of each file (#OPTION:TOC nil). My secondary concern is that the auto-fill-mode behavior of emacs is actually kind of ruining readability in markdown presentation, so ideally I'd like to fix that as well. How the hell we do that, I have no idea. I know how to do it manually (select all buffer text, set fill column to LARGE n, call fill-paragraph), but none programaticaly. Maybe I just script that behavior right there?\"), mdx(\"p\", null, \"Finally, one nice thing would be to add a single, top level heading to each exported markdown file that is the title of the note. \"), mdx(\"h2\", null, \"Success!\"), mdx(\"p\", null, \"So this is pretty exciting, but I've finally finished my first non-trivial application of emacs lisp. The file autoExport.el (currently in this directory, but may be moved somewhere else soon) has a handful of functions I wrote this morning in ELisp to automate the export of my zettelkasten notes to markdown format. Whether or not this was a good idea, remains to be seen!\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"202008161707-emacs-lisp-project"}},"staticQueryHashes":[]}