{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\optimization-algorithms-rely-deeply-on-function-evaluation","result":{"data":{"brainNote":{"slug":"optimization-algorithms-rely-deeply-on-function-evaluation","title":"optimization-algorithms-rely-deeply-on-function-evaluation","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"optimization-algorithms-rely-deeply-on-function-evaluation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Optimization is Function Evaluation\"), mdx(\"p\", null, \"When considering an optimization problem, we state the problem itself as some type of function:\"), mdx(\"p\", null, \"Minimize f(x, u, t)\\nSubject to g(x,u,t) <= 0\\nand            h(x,u,t) = 0\"), mdx(\"p\", null, \"Really, three different groups of functions. So at every step in an optimization process, our entire focus is on these three function groups. Since they are mathematical functions, they must be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"pure functions\"), \", and thus cannot have any sort of state. This is excellent for parallelization, because pure functions can be trivially scaled. \"), mdx(\"p\", null, \"The key issue then, once we've parallelized all of these function evaluations, is to come up with a sensible orchestration scheme, for getting the functions evaluated at the right points so that the optimization progresses in a good, quick fashion. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"heterogeneous-computing-in-optimization","slug":"heterogeneous-computing-in-optimization","childMdx":{"excerpt":"GPUs are the Answer to Most Questions Not really, but they're pretty freaking slick at doing tons of the same computation on differentâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"optimization-algorithms-rely-deeply-on-function-evaluation"}},"staticQueryHashes":[]}