{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\20200702125313-permutations-in-fp","result":{"data":{"brainNote":{"slug":"20200702125313-permutations-in-fp","title":"20200702125313-permutations-in-fp","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200702125313-permutations-in-fp\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is quite a doozy, as I don't think there exists a way to do this arbitrarily in OOP/Imperative languages either, at least not easily thought of. If we know the number of lists/arrays we need to permute ahead of (compile) time, we can simply write the appropriate number of loops with appropriate end points (which can vary based on the size of each list/array). However, if we don't know the number of lists at compile time (or we want to design a method that's more flexible, say for library purposes), I think we \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"have\"), \" to go with the functional approach:\"), mdx(\"p\", null, \"Take two lists of arbitrary length, and return each of their permutations as a single list. Then, if we want to permute three or more lists, we simply compose these functions calls as\"), mdx(\"p\", null, \"new\", mdx(\"sub\", null, \"list\"), \" = permute(a, b)\"), mdx(\"p\", null, \"new\", mdx(\"sub\", null, \"many\"), mdx(\"sub\", null, \"lists\"), \" = permute(a, permute(b, permute(c, d)));\"), mdx(\"p\", null, \"Easy enough to do. Now it's just a matter of finding \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"20200702125803-permutations_of_two_collections.md\"\n  }), \"Permutations of two collections\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"20200619114230-functional-programming","slug":"20200619114230-functional-programming","childMdx":{"excerpt":"Functional programming is an interesting paradigm, and one that I've been attracted to (but not very successful in actually using) for quiteâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200702125313-permutations-in-fp"}},"staticQueryHashes":[]}