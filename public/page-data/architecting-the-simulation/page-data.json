{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\architecting-the-simulation","result":{"data":{"brainNote":{"slug":"architecting-the-simulation","title":"architecting-the-simulation","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"architecting-the-simulation\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Rehashing simWorld's Ideas\"), mdx(\"p\", null, \"Thinking it through, this would actually be the perfect time to bring simWorld back from the grave and repurpose a lot of its work. The key topics on my mind tonight as I get started are centered around data flow, modularity/reusability, and accuracy. \"), mdx(\"h1\", null, \"... Or Using a Different Library\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.pydy.org/documentation.html\"\n  }), \"Documentation \\u2014 PyDy Website\"), \" seems to be a perfect fit for what I'm trying to do, so I \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"may\"), \" end up using it to generate the simulation. I need to dig a little further to see if it's worth the trouble and exactly what I can use it for here. \"), mdx(\"h2\", null, \"PyDy is dead/subsumed\"), mdx(\"p\", null, \"By SymPy. Those docs are \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"much, much better\"), \" anyways: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://docs.sympy.org/latest/index.html\"\n  }), \"Welcome to SymPy\\u2019s documentation! \\u2014 SymPy 1.7.1 documentation\"), \". I have successfully created a small example project, and then modified it to create my own model of a simply 1-d linear actuator with SymPy. It even has code generation from the symbolic output! Next step will be to take this facility, get the Stewart Platform modeled in it completely, and get our forcing functions, mass matrices, and generalized derivatives out to use with something like SciPy's integrate functions to solve the simulation. Waaaaaaaay faster than trying to do all this stuff manually. Why wasn't I doing it this way years ago?!!\"), mdx(\"h1\", null, \"Moving On\"), mdx(\"p\", null, \"So we're using SymPy to generate the dynamics equations, and SciPy.odeint to do the integration for the simulation. What else do we really need? The Matplotlib.animation library seems super interesting, and if we can figure out how to draw the platform, we can see it in action very easily. \"), mdx(\"p\", null, \"I do need to figure out getting all of the state organized properly, so that I can plot the important bits easily. Likely use something like I did previously with the kalman filter stuff back at RTX, where I write all of the state and properties and such out to an HDF file, then post-process it to visualize. We could also very easily bring in something like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.paraview.org/\"\n  }), \"ParaView\"), \" to do the post-processing, so that I don't have to write a bunch of crap for the plots. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"kinematic-and-dynamic-modeling","slug":"kinematic-and-dynamic-modeling","childMdx":{"excerpt":"Modeling the Stewart Platform Is, unsurprisingly, rather difficult. Here's some literature on the subject: (PDF) Dynamic Modeling and…"}},{"title":"simulation-of-the-stewart-platform","slug":"simulation-of-the-stewart-platform","childMdx":{"excerpt":"Let's Sim this guy See  Architecting the Simulation  for the experimentation phase on how we got to the design for this software. With any…"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"architecting-the-simulation"}},"staticQueryHashes":[]}