{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\version-controlling-notes","result":{"data":{"brainNote":{"slug":"version-controlling-notes","title":"version-controlling-notes","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Important data should be recoverable!\"), mdx(\"p\", null, \"And that is one of the primary raisons d'etre of the modern, decentralized version control system! Of course, there's the hassle that comes along with using one for daily stuff that changes a lot, like having to write commit messages and remembering to commit your changes and such, but I have a feeling that I can pretty easily automate all that. This will even resolve a lot of the conflicts issues I've been having with OneDrive. The question is, of course, do I then \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"remove\"), \" my notes from OneDrive? Force myself to use a cloud hosting platform like GitHub or GitLab to host my notes, and use them that way? Seems like enough of an inconvenience that I won't want to be diligent about it. But using git to control versions, while keeping the git database within the OneDrive synced directories, seems ripe for fucking things up. \"), mdx(\"p\", null, \"20210113 - I went ahead and created a new GitHub private repository: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/gankoji/slipbox\"\n  }), \"gankoji/slipbox (github.com)\"), \". Now, I have the git local repo in OneDrive, which isn't great, but at least I have the remote setup for GitHub, and can keep a relatively constant backup with better resiliency than OneDrive. It's just a matter of making sure I update it on a daily or better basis. This doesn't \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"quite\"), \" fit in with the plan in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Cversion-control-plan\"\n  }), \"Version Control Plan\"), \", but it'll do for now. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[{"title":"version-control-plan","slug":"version-control-plan","childMdx":{"excerpt":"The How-To of Note-Fu Sometimes I write myself goofy notes like this, just to flex my pun muscles.  Okay, but on to the serious topic hereâ€¦"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"version-controlling-notes"}},"staticQueryHashes":[]}