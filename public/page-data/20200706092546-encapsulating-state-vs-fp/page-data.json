{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\20200706092546-encapsulating-state-vs-fp","result":{"data":{"brainNote":{"slug":"20200706092546-encapsulating-state-vs-fp","title":"20200706092546-encapsulating-state-vs-fp","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"20200706092546-encapsulating-state-vs-fp\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Going through this data structures project and starting to realize one of the downsides of the C language. For efficient insertion in a linked list, we can maintain a pointer to where the tail of the list is, in addition to having the head. But that is 'extra state' we need to manage per instance of the data structure. OOP gives us a very convenient way to handle this, but C doesn't. I'm wondering how, if at all, the functional languages handle this problem.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"20200619114230-functional-programming","slug":"20200619114230-functional-programming","childMdx":{"excerpt":"Functional programming is an interesting paradigm, and one that I've been attracted to (but not very successful in actually using) for quiteâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"20200706092546-encapsulating-state-vs-fp"}},"staticQueryHashes":[]}