{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\data-structures-for-notes-and-mappings","result":{"data":{"brainNote":{"slug":"data-structures-for-notes-and-mappings","title":"data-structures-for-notes-and-mappings","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Data Structures Thursday, June 4, 2020 11:22 AM\"), mdx(\"p\", null, \"How do we best represent a graph of notes that are bidirectionally linked? The first idea that springs to mind is the comparison between the traditional graph structures: edge matrices vs edge lists. What about nodes? Do they just get dumped in a linked list (or doubly linked list for ease of deletion, like I was talking about above)?\"), mdx(\"p\", null, \"Well, let's think about the operations we need.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Node Insertion. This one is probably the highest priority, since we expect\\nthat the normal use case is to open the application, add to existing notes, and create new ones.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Edge Insertion. This is almost as important, if not equal to, node insertion.\\nCreating links should be as low cost as possible.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Node update. Editing the data within a note should be real time, and updating\\nthe stored data (on an auto-save or manually started save) should also be as fast as possible.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Edge traversal. In order to build a graph view of the notes in the database,\\nwe need to be able to walk the graph quickly enough to build that view. Side point, how do we build that view?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Node location/search/retrieval. When the user engages a bidirectional link, we\\nwant to be able to immediately present the new note in a visually pleasing manner.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Node deletion. If the user no longer needs a note, we shouldn't keep it lying\\naround in the database, cluttering things up.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Edge deletion. This was discussed at length in \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"%5Clink-durability-in-notes\"\n  }), \"Link Durability in Notes\"), \"\\nShould trigger when node deletion is initiated by the user.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Edge search. Whenever we open up a new note, we immediately want to be able to\\npull up all links associated with it.\")), mdx(\"p\", null, \"So, to summarize: we need to support insertion, update (deletion and insertion at the same point), and location/search/retrieval for nodes, and we need insertion, deletion, search and traversal for edges. Ideally, these should all be as fast as possible, but we have some priorities. Insertion for both data structures should be fastest. Traversal should be right behind for the edges. Update on nodes can be slightly slower, although we don't want the system to bog down on save. Location should be lightning quick too, which makes it difficult to choose a data structure that has all of these elements.\"), mdx(\"p\", null, \"We know that some sort of tree is likely the answer, since balanced search trees, AVL trees, b-trees and their variants, all support insertion, deletion, and search/retrieval in O(log n).\"), mdx(\"p\", null, \"For the edges, I favor the doubly linked list here. Traversal is O(n). Insertion is O(1). But, with a doubly linked list, search is O(n), and deletion is also O(n) due to needing to search for the item to be deleted. Maybe doubly linked lists aren't as good as I thought they were.\"), mdx(\"p\", null, \"Okay, so doubly linked lists aren't a great structure here for the edges. Edge arrays/matrices would be more problematic though! Let's work through it. Traversal is O(n\", mdx(\"sup\", null, \"2\"), \"). Insertion is O(1) still. Search is O(n). Deletion is O(1). Search is O(n). That approach wouldn't work either. Looks like we need to dig further.\"), mdx(\"p\", null, \"Singly linked lists are out, since they have as bad or worse performance than doubly linked lists in the operations we care about. It seems that some sort of tree is the way to go here. There are more exotic data structures available, like tries, but I think a tree would be a good compromise. Maybe an AVL or red-black tree would be appropriate. Do we expect this entire data structure to fit in a machine's memory? Or should we design it like a B tree for on disk persistence?\"), mdx(\"p\", null, \"The bigger question I have is, at the moment, would it just be better to use a pre-built graphDB solution? There are some of those, but I have no idea as to their performance, ease of use, or developer velocity potential.\"), mdx(\"p\", null, \"Other things to consider: \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Cnote-privacy\"\n  }), \"Note Privacy\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Csolving-bidirectionality\"\n  }), \"Solving Bidirectionality\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"the-jakenotes-app","slug":"the-jakenotes-app","childMdx":{"excerpt":"A Notetaker, Then I've noted on the inner working of a note taking app like Roam, Obsidian, and others before, starting with  Data…"}}],"outboundReferenceNotes":[{"title":"link-durability-in-notes","slug":"link-durability-in-notes","childMdx":{"excerpt":"Link Durability Thursday, June 4, 2020 11:09 AM How do we solve the question of link durability, but still allow the flexibility that users…"}},{"title":"note-privacy","slug":"note-privacy","childMdx":{"excerpt":"Note Privacy Thursday, June 4, 2020 11:29 PM While OneNote is great at handling tons of media formats, being always accessible (even on…"}},{"title":"solving-bidirectionality","slug":"solving-bidirectionality","childMdx":{"excerpt":"Solving Bidirectionality Thursday, June 4, 2020 11:02 AM So a question I've come across today is that of implementing Bidirectionality in…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"data-structures-for-notes-and-mappings"}},"staticQueryHashes":[]}