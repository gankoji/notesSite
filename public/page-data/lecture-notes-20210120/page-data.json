{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\lecture-notes-20210120","result":{"data":{"brainNote":{"slug":"lecture-notes-20210120","title":"lecture-notes-20210120","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"More on Dual Problems and Convex Programming\"), mdx(\"p\", null, \"Looks like we're spending the first portion of class going through some examples on how to solve these dual problems that arise in convex programming. Refer to the lecture notes in OneNote for the problems. \"), mdx(\"p\", null, \"As a reminder here, we form the dual problem by multiplying the constraints by Lagrange multipliers, and then forming the sensible optimization problem on the lagrange multipliers (by looking for upper bounds on the original objective via combinations of the constraints). \"), mdx(\"h2\", null, \"Key Example\"), mdx(\"p\", null, \"Maximize $2x_1 + 3 x_2 - x_3$\\nST $(x_1, x_2) \\\\geq 0, x_3 \\\\in \\\\mathbb{R}$\\n$2x_1 + x_2 \\\\leq 3$\\n$x_1 - x_3 = 1$\\n$x_1 + x_2 + x_3 \\\\geq 4$\"), mdx(\"p\", null, \"We're searching for an upper bound on the maximum of the objective function, so we turn to the linear combination of the constraints.\"), mdx(\"p\", null, \"We can straightforwardly say $l_1(2x_1+x_2) + l_2(x_1-x_3) + l_3(x_1 + x_2 + x_3) \\\\leq 3l_1 + l_2 + 4l_3$, provided that $l_1 \\\\geq 0, l_3 \\\\leq 0, l_2 \\\\in \\\\mathbb{R}$. \"), mdx(\"p\", null, \"Finally, we want to write the dual problem as\"), mdx(\"p\", null, \"Minimize $3l_1 + l_2 + 4l_3$\\nSubject to $l_1 \\\\geq 0, l_2 \\\\in \\\\mathbb{R}, l_3 \\\\leq 0$\\n$2l_1 + l_2 + l_3 \\\\geq 2$\\n$l_1 + l_3 \\\\geq 3$\\n$-l_2 + l_3 = -1$\"), mdx(\"h2\", null, \"The Real Mindbender here\"), mdx(\"p\", null, \"If we write the primal problem as a set of Matrix statements:\"), mdx(\"p\", null, \"Maximize $\\\\hat{c}^T\\\\hat{x}$\\nSubject to $A\\\\hat{x} + \\\\hat{b} \\\\leq 0$\"), mdx(\"p\", null, \"Then we can directly write the dual problem as a set of transposes:\"), mdx(\"p\", null, \"Minimize: $\\\\hat{b}^T\\\\hat{\\\\lambda}$\\nSubject to $A^T\\\\hat{\\\\lambda} + \\\\hat{c} \\\\leq 0$\"), mdx(\"p\", null, \"There are some conditions on the inequalities and variable constraints that must be dealt with as well, and those can be seen in the table in the notes. (reproduced here). \"), mdx(\"p\", null, mdx(\"img\", _extends({\n    parentName: \"p\"\n  }, {\n    \"src\": \"%5Cpasted-image-20210120104700png\",\n    \"alt\": \"Pasted image 20210120104700.png\"\n  }))), mdx(\"p\", null, \"If we instead remove the objective from the dual problem, and say 'Minimize: 0' with the same constraints, we could solve for the feasible region of the original problem. \"), mdx(\"h1\", null, \"The Key Insight\"), mdx(\"p\", null, \"If we take the difference between the primal and dual objective values and minimize it, we will solve the original problem. In addition to this happy circumstance, we also find that this difference in these objectives tells us 'how far we are' from the solution. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[{"title":"pasted-image-20210120104700png","slug":"pasted-image-20210120104700png","childMdx":{"excerpt":""}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"lecture-notes-20210120"}},"staticQueryHashes":[]}