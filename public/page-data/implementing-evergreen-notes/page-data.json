{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/implementing-evergreen-notes","result":{"data":{"brainNote":{"slug":"implementing-evergreen-notes","title":"implementing-evergreen-notes","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"implementing-evergreen-notes\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So what do we need in order to provide an environment for creating Evergreen notes? I think the first and most important part to include is usable bidirectional linkage. A usable graph view might be a good tip as well. The point of Evergreen notes is to be highly linked, and thus discoverable.\"), mdx(\"p\", null, \"Another key point is that the notes have to be usable! It does anyone no good to make a bunch of notes just to not be able to use them effectively later! That is precisely the problem I've experienced with org-mode notes. I have just pages and pages of text stored deep in org files, all beautifully organized, but basically useless, as I don\\u2019t remember much of any of it except for the main topics.\"), mdx(\"p\", null, \"I've been using Roam lately, and I feel that it succinctly meets these requirements, both in linkability and in usability of previous notes. As I mentioned in the quick notes, Roam has issues that I don't see being resolved anytime soon. So this adds another requirement to my list: a usable notes system must be selectively private. We should have the ability to publish notes we feel are useful to do so for, but we must also be able to easily, simply, keep others private. Since we have this privacy requirement, we're going to have to design this app from the ground up to be safe in a highly available/accessible environment.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"implementing-evergreen-notes"}},"staticQueryHashes":[]}