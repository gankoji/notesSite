{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\incorporating-hardware-and-software-in-simulation","result":{"data":{"brainNote":{"slug":"incorporating-hardware-and-software-in-simulation","title":"incorporating-hardware-and-software-in-simulation","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"HW/SW in Sim\"), mdx(\"p\", null, \"I'm envisioning a way to be super productive in iterating on the design of this guy. I've already got a pretty good headstart today by going through the motions of learning SymPy, so the mathematics for the dynamics and such are very much simplified. I love the idea of being able to generate the functions I use to simulate the system, and I want to extend that a little further. \"), mdx(\"p\", null, \"Once we get to the point where an initial cut has been taken at the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Celectrical-design-elements\"\n  }), \"Electrical Design Elements\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Cmechanical-design-elements\"\n  }), \"Mechanical Design Elements\"), \", I want to be able to completely regenerate/rerun the simulation with the exact parameters that are output from the electrical or mechanical design processes. This is going to require a little bit of forethought from me, as I need to design those elements such that they're computable. \"), mdx(\"h2\", null, \"Deepening the models\"), mdx(\"p\", null, \"Before we get to actually building out a prototype, I think it's worth the trouble to go deeper on our models than will be used throughout the initial control design phase. Things like backlash in the actuators, actual joint friction models, noisy sensors, etc. One of the thoughts I've had tonight is to include an IMU on the moving platform, to see if that type of feedback would be useful in the control process or not. I have a feeling it would be. \"), mdx(\"h2\", null, \"Models to Add\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Actuator disturbances (backlash for gears, motor models for electric, cavitation/cfd for hydraulics?)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sensor noise\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Joint friction\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"IMU (re-use HG9900 from conference paper)\")), mdx(\"h2\", null, \"How to combine these with the SymPy generation?\"), mdx(\"p\", null, \"That's the real question here. I've never had to use this type of non-ideal modeling with a direct mathematical approach, since they're really much easier to specify as 'programming models', versus mathematical functions. In particular, things like hysteresis/vicous damping will have to have state in them. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"the-stewart-platform-project","slug":"the-stewart-platform-project","childMdx":{"excerpt":"Going back to my roots Struggled a bit this week (20201231, end of 2020!) to come up with a new project, since  The HomeBackup Project  andâ€¦"}}],"outboundReferenceNotes":[{"title":"electrical-design-elements","slug":"electrical-design-elements","childMdx":{"excerpt":""}},{"title":"mechanical-design-elements","slug":"mechanical-design-elements","childMdx":{"excerpt":""}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"incorporating-hardware-and-software-in-simulation"}},"staticQueryHashes":[]}