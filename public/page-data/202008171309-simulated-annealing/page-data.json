{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/202008171309-simulated-annealing","result":{"data":{"brainNote":{"slug":"202008171309-simulated-annealing","title":"202008171309-simulated-annealing","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Simulated Annealing is another global optimization strategy, and is actually quite similar to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/202008171306-genetic-algorithms\"\n  }), \"202008171306 Genetic Algorithms\"), \". The core principles are identical: randomly sample the state space, calculate the cost or fitness function of the samples, morph them according to some rule, and carry on until reaching a convergence criterion. \"), mdx(\"p\", null, \"The key difference is that the decision to morph a sample is itself a random variable, whose likelihood is determined as an exponentially decaying function of the overall 'temperature' of the model (higher 'temperatures' lead to more random walks), which cools over time, just as in a real annealing process. This leads to tons of exploration of the state space at first, but the likelihood is generally built so that only 'more fit' samples are kept unless the temperature is high and/or a good draw says to take the worse step. As time goes on and samples converge, the temperature is slowly lowered for the model, and eventually we should get samples that 'settle down' into or near the global optima. \"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/dissertation-topic-ideas\"\n  }), \"Dissertation Topic Ideas\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"more-on-reinforcement-learning","slug":"more-on-reinforcement-learning","childMdx":{"excerpt":"I thought through this quite a bit last night, and I came up with some more questions that I don't necessarily have answers to, at the…"}}],"outboundReferenceNotes":[{"title":"202008171306-genetic-algorithms","slug":"202008171306-genetic-algorithms","childMdx":{"excerpt":"Genetic Algorithms are generally classified as one type of optimization solver. The idea is effectively to randomly select starting points…"}},{"title":"dissertation-topic-ideas","slug":"dissertation-topic-ideas","childMdx":{"excerpt":"Seems I never got around to doing anything here. Obviously, I need to start fleshing out a list of ideas for the dissertation. Jarvis  is…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"202008171309-simulated-annealing"}},"staticQueryHashes":[]}