{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\memory-mapping-in-c","result":{"data":{"brainNote":{"slug":"memory-mapping-in-c","title":"memory-mapping-in-c","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This is a continuation of sorts of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Cfile-data-structures\"\n  }), \"File Data Structures\"), \". An idea that came up is to memory map the three files we're using (input, temp, and output) to make managing the blocks easier from the program's perspective. One note is that the size of the file can be rather huge for 64 bit programs (exabytes IIRC) because you're only limited by the virtual memory space, not the actual physical memory onboard the system. \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/questions/41288602/how-does-a-memory-mapped-file-work-for-files-larger-than-memory\"\n  }), \"This\"), \" thread offers a good overview from a high level. It also links to \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gnu.org/software/libc/manual/html_node/Memory_002dmapped-I_002fO.html\"\n  }), \"this page of the GNU libc manual\"), \" to get a bit more in depth. The functions used are mmap, mmap64 (if in a 32 bit program), and msync (effectively like flush for normal I/O). \"), mdx(\"p\", null, \"I need to find a tutorial on this, to make sure I get it right from the get go, but I think this is the answer to my architecture problem. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"sorting-large-files-with-memory-mapping","slug":"sorting-large-files-with-memory-mapping","childMdx":{"excerpt":"Memory Mapping in C  got this topic started, now it's time to get down to brass tax and sort out the details related to the PiSort program…"}}],"outboundReferenceNotes":[{"title":"file-data-structures","slug":"file-data-structures","childMdx":{"excerpt":"The last major piece of the  GreedSort  puzzle that I've yet to solve to satisfaction is that of how to store, pass, and otherwise handle…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"memory-mapping-in-c"}},"staticQueryHashes":[]}