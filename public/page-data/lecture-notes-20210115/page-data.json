{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\lecture-notes-20210115","result":{"data":{"brainNote":{"slug":"lecture-notes-20210115","title":"lecture-notes-20210115","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"lecture-notes-20210115\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"20210115\"), mdx(\"p\", null, \"Starting where we left off, on linear programming\"), mdx(\"h2\", null, \"Linear Programming\"), mdx(\"p\", null, \"A linear program is an optimization problem formed as follows:\"), mdx(\"p\", null, \"Minimize $c^Tx + d$\\nSubject to $Ax \\\\leq b$, or $Ax + b \\\\leq 0$. \"), mdx(\"p\", null, \"The first question to answer is: is this problem feasible? I.e. is the set $D = \\\\cap \", \"{\", \"x  | Ax + b \\\\leq 0\", \"}\", \"$ non-empty. \"), mdx(\"h3\", null, \"Bounding the maximum\"), mdx(\"p\", null, \"By transforming the constraints, and seeing which ones actually drive the optimization solution (i.e. finding 'active' constraints). We can also take positive linear combinations of all the constraints, in any form we like. Any positive linear combination of the inequality constraints give valid bounds. \"), mdx(\"p\", null, \"This leads rather nicely to a matrix equation of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"weighted\"), \" linear inequalities:\"), mdx(\"p\", null, \"$\\\\lambda A\\\\hat{x} \\\\leq \\\\lambda\\\\hat{b}$\"), mdx(\"p\", null, \"We want to find the $\\\\lambda$ such that the left side leads to the objective function, and the right side is as small as possible. This is the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"dual problem\"), \" of the orginal optimization problem, also called the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"primal problem\"), \". Written explicitly, our dual problem is now\"), mdx(\"p\", null, \"Minimize $\\\\lambda \\\\hat{b}$\\nSubject to $\\\\lambda A \\\\hat{x} \\\\geq c$ and $\\\\lambda \\\\geq 0$. \"), mdx(\"h4\", null, \"Weak Duality\"), mdx(\"p\", null, \"The value of the primal problem is less than or equal to the value fo the dual problem. \"), mdx(\"p\", null, \"If we can find candidate feasible points for both problems, such that the value of the dual is less than or equal to the value of the primal, we have solved the optimization problem. \"), mdx(\"h2\", null, \"The Geometry of Linear Programming\"), mdx(\"p\", null, \"A linear programming problem is infeasible if we cannot simultaneously satisfy all the constraints. Conversely, it is unbounded if the objective function is not bounded on the feasible set. These are inversely related to the same properties for the dual problem! An infeasible primal problem leads to an unbounded dual problem, and an unbounded primal problem leads to an infeasible dual problem. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"lecture-notes-20210115"}},"staticQueryHashes":[]}