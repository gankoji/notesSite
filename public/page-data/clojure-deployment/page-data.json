{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\clojure-deployment","result":{"data":{"brainNote":{"slug":"clojure-deployment","title":"clojure-deployment","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"clojure-deployment\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Getting this Code Running\"), mdx(\"p\", null, \"RIght now, the way to run this project is simply 'lein run' from the command line. That's not a great experience, since you need to have Leiningen on the target machine, and it goes through it's whole dependency get and build cycle everytime you want to run. \"), mdx(\"p\", null, \"Leiningen has the capability to output Jar files, which seems a logical next step. The trouble after that, of course, is that you still need to get the jar file from the build machine (lets say my desktop for now) over to the target machine (the Pi). Then, you have to also ensure that any depdencies you have are on the target machine as well. Finally, you have to have some sane way to configure the new deployment and actually get it running. Sounds like an obvious candidate for containerization, right? \"), mdx(\"p\", null, \"If this is going to be something that runs constantly as  background service, I'm going to need an easy interface to see it running, making progress, and change it's configuration at will by the user. If I do it the 'cloud native' microservice way, that's quite a bit of extra infrastructure I kinda have to build myself, unless I can bring in some other project dependencies that automate these other issues. I think those exist, but I need to find out. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"making-architectural-decisions","slug":"making-architectural-decisions","childMdx":{"excerpt":"The HomeBackup Project Next, the architecture plan: Think through  Clojure Deployment . Figure out a convenient way to get this code up and…"}},{"title":"todos-over-the-holidays-2020","slug":"todos-over-the-holidays-2020","childMdx":{"excerpt":"TBD OBE I haven't actually been able to sync data from the desktop to the PiNAS for a long time now, and I should fix that.  DONE I guess…"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"clojure-deployment"}},"staticQueryHashes":[]}