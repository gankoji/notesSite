{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\restoring-a-backup-from-azure","result":{"data":{"brainNote":{"slug":"restoring-a-backup-from-azure","title":"restoring-a-backup-from-azure","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"restoring-a-backup-from-azure\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Getting Data Out of the Cloud\"), mdx(\"p\", null, \"Let's run through the wishlist before we hit specifics. \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Automated, completely. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Automatic retries, progress marking (downloads will take a while)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Select versions/dates of backups?\")), mdx(\"h2\", null, \"The plan\"), mdx(\"p\", null, \"This capability should be broken up as much as possible. We'll need to figure out what the data should look like (versus what the local data \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"does\"), \" look like when we start). This might need to be done with every download, so design it to handle that type of use. \"), mdx(\"p\", null, \"Then, we'll need to download the compressed/encrypted data. This should have the ability to use as much or as little of the user's bandwidth as desired, and should be configurable by the user as easily as possible. If we get the whole pipe, we better use the whole pipe. \"), mdx(\"p\", null, \"Then, we'll need to decompress and/or decrypt the data. These two steps could very easily be separated. It could also be done in flight/on vm instances/with serverless functions. Need to balance data safety versus computational power. \"), mdx(\"p\", null, \"Finally, we'll need to collect the inflated/decrypted data at its final resting place. This might need to be queued/chunked/etc to make best use of available disk bandwidth from memory. Think through passing that data around from these processes/threads/services to minimize use of spinning platters and maximize use of sytem RAM and cheap RAM (SSDs). \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"making-architectural-decisions","slug":"making-architectural-decisions","childMdx":{"excerpt":"The HomeBackup Project Next, the architecture plan: Think through  Clojure Deployment . Figure out a convenient way to get this code up andâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"restoring-a-backup-from-azure"}},"staticQueryHashes":[]}