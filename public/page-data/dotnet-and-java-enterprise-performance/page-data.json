{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\dotnet-and-java-enterprise-performance","result":{"data":{"brainNote":{"slug":"dotnet-and-java-enterprise-performance","title":"dotnet-and-java-enterprise-performance","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"dotnet-and-java-enterprise-performance\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The great calling card of these managed and hosted langauges is the developer velocity which they help us achive. There's so many libraries and so much prebuilt and highly available code that it's incredibly easy and fast to whip up an application prototype. This comes with a disadvantage, though, which is the subject of this note.\"), mdx(\"p\", null, \"Having canned methods for things like building a list of strings, for example, is great for prototyping. No need to consider what sort of data structure to use, no need to write the wrapper/helper methods to add things and remove them, etc. BUT, you also \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"don't get a choice\"), \" in how those particular pieces of functionality are implemented. It's also not obvious immediately from the name of the package and class you use, often, exactly what sort of underlying data structure and algorithms are being used to manage that object. This is the major 'back half' of Object-Oriented Programming's double edged sword: so much is abstracted away from the programmer that it's difficult to know immediately exactly what you're signing your system up for.\"), mdx(\"p\", null, \"I think that this single factor is probably a bigger deal to the perceived slowness and resource inefficiency of managed platform programs than the VM or runtime environment. It's been shown again and again that the JVM is nearing speed parity with bare metal languages, and the CLR is even closer. But these tests and benchmarks people write are often done with manually built classes, as opposed to utilizing boilerplate methods and classes available in the standard libraries. I've yet to see a good comparison that uses more boilerplate code, where the issue at hand is, in my opinion.\"), mdx(\"p\", null, \"The key issue here is that the choices made by the library implementers are the decisions you're stuck with. If they choose to implement their object which concatenates strings (StringBuilder) with an underlying DynamicArray, that will give you one set of performance characteristics and constraints, as opposed to utilizing a singly or doubly linked list for the pieces of the string as you add them. Depending on your use case, you might need really fast inserts, because that's part of a user interface element, while the generation of the overall string can be done leisurely in the background. The DynamicArray would be precisely the wrong choice here, as an insert that went over the current size, when N is large, could cause UI stuttering or even lock up while a significant portion of memory is allocated, copied, and the old location released. The opposite choice would be better if you needed faster string output than insert.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"windoze-index","slug":"windoze-index","childMdx":{"excerpt":"Azure \n Azure Functions \n DotNET and Java Enterprise Performance \n Powershell Quirks"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"dotnet-and-java-enterprise-performance"}},"staticQueryHashes":[]}