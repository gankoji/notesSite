{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/file-data-structures","result":{"data":{"brainNote":{"slug":"file-data-structures","title":"file-data-structures","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The last major piece of the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/greedsort\"\n  }), \"GreedSort\"), \" puzzle that I've yet to solve to satisfaction is that of how to store, pass, and otherwise handle pointers to the blocks/temp files. My initial thought was to use many small temp files, one per run at each merge level. However, this is less than ideal for multiple reasons: 1) Individual files requires managing file handles/pointers \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"and\"), \" filenames (assuming we open and close them repeatedly), 2) we're depending on file creation mechanisms for our storage space, which likely incurs some overhead in the system calls. \"), mdx(\"p\", null, \"My latest idea (which needs to be fleshed out), is to simply use one large OS file for each of the temporary files/runs, since we know the cumulative size of the runs is bounded (it can't be any bigger than the input). This also allows us to swap back and forth between input and output files, if we want to overwrite our input files, or we can do a minimal disk space implementation with a third temporary file. \"), mdx(\"p\", null, \"What this does require though, I think, is a dynamically allocated list/array of file pointers to different locations within the temp file, each one pointing to the beginning of a run or block within one of the runs. It seems that doing this concurrently is a nonstarter (writing multiple locations at once within the same file), but it might still make sense if all I'm doing is specifying a location and data in a queue, and then having one worker writing the data back out to the file in a sequential fashion. Multiple file descriptors seems like a huge headache, though. Is mmap the real answer here? Does that make our solution not platform independent?\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"b-trees","slug":"b-trees","childMdx":{"excerpt":"B-Trees B-Trees are one of several  File Data Structures   that were originally designed (and still largely used) for the purpose of what…"}},{"title":"memory-mapping-in-c","slug":"memory-mapping-in-c","childMdx":{"excerpt":"This is a continuation of sorts of  File Data Structures . An idea that came up is to memory map the three files we're using (input, temp…"}}],"outboundReferenceNotes":[{"title":"greedsort","slug":"greedsort","childMdx":{"excerpt":"The Actual Algorithm behind the PiSort project See  202008181021 Breaking Down GreedSort  for more details. Here, I want to give a very high…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"file-data-structures"}},"staticQueryHashes":[]}