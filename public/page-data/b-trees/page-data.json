{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\b-trees","result":{"data":{"brainNote":{"slug":"b-trees","title":"b-trees","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"B-Trees\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"B-Trees are one of several \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"%5Cfile-data-structures\"\n  }), \"File Data Structures\"), \"  that were originally designed (and still largely used) for the purpose of what Knuth calls external searching.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"External searching refers to the fact that some datastores are far too large to fit the entirety of the data within any single computer's main memory. Some data structures have been designed to explicitly handle the problem of searching for data with a specified key within these data stores.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Unfortunately, the techniques available for internal searching, while great for speed when data is in memory, are limited for external search. The trouble is that if the tree was paged onto disk, most of the keys used for search would end up in these pages, since they're stuffed down the tree, and thus we'd have to spend time accessing the disk for each key comparison.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"B-Trees get around this limitation in binary searching methods by allowing the search tree to branch further. Knuth calls this concept Multiway Trees, which is a pretty apt description.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The essential concept is simple: rather than letting each node reside on its own in memory or storage, we group them together into pages of n records each. Then, we access each page all at once, with a single disk access, and use elementary in memory methods to go through the page until we find the right key. This way, we can minimize the number of disk accesses to find an arbitrary key in an arbitrarily large number of records, since each access will allow us to search through n records at a time.\")))), mdx(\"h3\", null, \"Definition\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A B-Tree of order m have the following properties\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every node has at most m children.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Every node, except for the root and the leaves, has at least\\nfloor(m/2) children.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The root has at least 2 children, unless it is a leaf (the tree is\\nempty).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All leaves appear on the same level, and carry no information.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A nonleaf node with k children contains k-1 keys.\")))), mdx(\"h3\", null, \"Implementation\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Cb-tree-implementation\"\n  }), \"B-Tree Implementation\"), \" has the details. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"data-structures","slug":"data-structures","childMdx":{"excerpt":"Project - Data Structures GreedSort Other Data Structures B-Trees \n 20200620175608-b_trees \n 20200620210305-heaps_data_structure \n LRU cache…"}}],"outboundReferenceNotes":[{"title":"file-data-structures","slug":"file-data-structures","childMdx":{"excerpt":"The last major piece of the  GreedSort  puzzle that I've yet to solve to satisfaction is that of how to store, pass, and otherwise handle…"}},{"title":"b-tree-implementation","slug":"b-tree-implementation","childMdx":{"excerpt":"Implementing a B-Tree OK so the choice of storing data in the leaves or not isn't super important to the b tree. I think the major…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"b-trees"}},"staticQueryHashes":[]}