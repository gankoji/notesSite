{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/202008181021-breaking-down-greedsort","result":{"data":{"brainNote":{"slug":"202008181021-breaking-down-greedsort","title":"202008181021-breaking-down-greedsort","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"202008181021-breaking-down-greedsort\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Breaking Down GreedSort\"), mdx(\"h2\", null, \"GreedSort - Vitter and Nodine\"), mdx(\"p\", null, \"[1]\", \" - Nodine, Mark H. and Vitter, Jeffrey Scott, \\\"Greed Sort: Optimal Deterministic Sorting on Parallel Disks\\\", Journal of the ACM, Vol 42, No 4, July 1995, pp 919-933\"), mdx(\"p\", null, \"GreedSort is an algorithm published in the referenced article above which first successfully used the parallel disk model to accurately model hierarchical memory systems in reference to the sorting problem. This algorithm is also important in that it was, to my knowledge, the first successfully 'optimal' algorithm in a deterministic and worst case sense. Other algorithms before it could get 'optimal' (a constant factor of the lower bound, in their lexicon) in the average and best cases, but their worst cases were not bounded because they were random in nature. \"), mdx(\"h3\", null, \"Key Ideas\"), mdx(\"p\", null, \"Utilize, to the greatest extent possible, the ability of a multithreaded processor and multiple disks to saturate an I/O bus by reading from and writing to all disks simultaneously as often as possible.\\nThe algorithm is a type of merge sort, where we merge R = sqrt(M/B)/2 runs at once. M and B are parameters of the system, specifically the system memory used by the process and the disk block size. \"), mdx(\"p\", null, \"The key idea in the merge process is that we keep some metadata on each run that we're merging, specifically which block is next (that part is still a bit confusing), what's the biggest value in a sorted block and what's the smallest value. These are used to select the best 2 blocks to sort at each iteration of the inner merge loop, which runs exhaustively over the blocks in the R runs we're merging at this step. Once that is done, we've actually only got an approximate sorting, so we read the whole output file back a bit at a time and use another algorithm (called Columnsort, and described in reference \", \"[2]\", \") to complete the merge. This middle loop is repeated until we have only 1 run remaining, and the sort is then complete. \"), mdx(\"p\", null, \"When we are merging runs, each run starts out as a single memory load long, M/B blocks in length. As merging goes on, these runs get less numerous, but larger in size. We work at the block size level: reading a two blocks at each iteration of the innermost loop (this could be in parallel, but its two blocks per thread). \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"greedsort","slug":"greedsort","childMdx":{"excerpt":"The Actual Algorithm behind the PiSort project See  202008181021 Breaking Down GreedSort  for more details. Here, I want to give a very highâ€¦"}}],"outboundReferenceNotes":[]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"202008181021-breaking-down-greedsort"}},"staticQueryHashes":[]}