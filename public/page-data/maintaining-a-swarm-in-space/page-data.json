{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/\\maintaining-a-swarm-in-space","result":{"data":{"brainNote":{"slug":"maintaining-a-swarm-in-space","title":"maintaining-a-swarm-in-space","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"A Swarm in Space\"), mdx(\"p\", null, \"This is probably the most interesting part of the space microbot project. How do you keep them all running smoothly? What happens if they run into each other, or an object they're working on? What about wear and malfunctions in the equipment? Do you build a depot with bigger space robots that can repair each little one, maybe the same robot that builds them in the first place? Sure, that sounds reasonable. \"), mdx(\"p\", null, \"Other questions remain: how do you orchestrate them all in the first place. Who decides which bots go to which place, and do what? That's sort of the thrust of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"%5Ctask-assignment\"\n  }), \"Task Assignment\"), \", but a little bit higher level. How do we decide what tasks must be done? Obviously, some sort of human intervention or cooperation is probably going to be necessary. This is the kind of software that needs to be developed over years or even a decade, incorporating feedback cycles from real world use. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"what-makes-an-intelligent-swarm","slug":"what-makes-an-intelligent-swarm","childMdx":{"excerpt":"Decomposing the Problem Coming to the specific application of a massive swarm (let's say N=1e5 or 1e6 for this discussion) of robots, maybeâ€¦"}}],"outboundReferenceNotes":[{"title":"approximate-gradients","slug":"task-assignment","childMdx":{"excerpt":"TK"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"maintaining-a-swarm-in-space"}},"staticQueryHashes":[]}