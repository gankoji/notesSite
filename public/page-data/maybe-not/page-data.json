{"componentChunkName":"component---node-modules-gatsby-theme-andy-src-templates-note-js","path":"/maybe-not","result":{"data":{"brainNote":{"slug":"maybe-not","title":"maybe-not","childMdx":{"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"There May Be Room!\"), mdx(\"p\", null, \"So, after a more thorough review of what's on the market in \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"/current-state-of-the-art\"\n  }), \"Current state of the art\"), \", I'm less convinced tonight than I was a couple days ago of the doomedness of this project. There are some tools out there that make it easier to program for GPUs and FPGAs, but they're primarily centered around annotating existing code to get it to speed up. They're basically trying to shoehorn GPGPU/massive parellelism into already existing languages. \"), mdx(\"h3\", null, \"Is a new language necessary?\"), mdx(\"p\", null, \"I'm not sure that a complete reinvention of the wheel is necessary, but I do think that the freedom allowed by going in that direction would allow pretty significant room for creativity in solving this problem. I'm not convinced yet, but I'll keep mulling it over and seeing what I can turn up. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"inboundReferenceNotes":[{"title":"current-state-of-the-art","slug":"current-state-of-the-art","childMdx":{"excerpt":"GPGPU Tools on the Market OpenACC OpenACC  is a mature set of extensions to native C compilers that allow the programmer to decorate…"}},{"title":"gpgpu-productivity","slug":"gpgpu-productivity","childMdx":{"excerpt":"Improving GPGPU This project is aimed at finding out about the latest and greatest in GPGPU technology, looking for tools, platforms, and…"}}],"outboundReferenceNotes":[{"title":"current-state-of-the-art","slug":"current-state-of-the-art","childMdx":{"excerpt":"GPGPU Tools on the Market OpenACC OpenACC  is a mature set of extensions to native C compilers that allow the programmer to decorate…"}}]},"site":{"siteMetadata":{"title":"Jake's Notes"}}},"pageContext":{"slug":"maybe-not"}},"staticQueryHashes":[]}